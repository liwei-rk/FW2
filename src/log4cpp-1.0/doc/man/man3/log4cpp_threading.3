.TH "log4cpp::threading" 3 "3 Oct 2012" "Version 1.0" "log4cpp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
log4cpp::threading \- 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBThreadLocalDataHolder\fP"
.br
.ti -1c
.RI "class \fBMSMutex\fP"
.br
.RI "\fIA simple object wrapper around CreateMutex() and DeleteMutex(). \fP"
.ti -1c
.RI "class \fBMSScopedLock\fP"
.br
.RI "\fIA simple object wrapper around WaitForSingleObject() and ReleaseMutex(). \fP"
.ti -1c
.RI "class \fBMutex\fP"
.br
.ti -1c
.RI "class \fBScopedLock\fP"
.br
.RI "\fIdefinition of \fBScopedLock\fP; \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef boost::mutex \fBMutex\fP"
.br
.ti -1c
.RI "typedef boost::mutex::scoped_lock \fBScopedLock\fP"
.br
.ti -1c
.RI "typedef int \fBMutex\fP"
.br
.RI "\fIDummy type 'int' for \fBMutex\fP. \fP"
.ti -1c
.RI "typedef int \fBScopedLock\fP"
.br
.RI "\fIDummy type 'int' defintion of \fBScopedLock\fP;. \fP"
.ti -1c
.RI "typedef \fBMSMutex\fP \fBMutex\fP"
.br
.RI "\fIA simple, non recursive \fBMutex\fP. \fP"
.ti -1c
.RI "typedef \fBMSScopedLock\fP \fBScopedLock\fP"
.br
.RI "\fIA simple 'resource acquisition is initialization' idiom type lock for \fBMutex\fP. \fP"
.ti -1c
.RI "typedef omni_mutex \fBMutex\fP"
.br
.RI "\fIA simple, non recursive \fBMutex\fP. \fP"
.ti -1c
.RI "typedef omni_mutex_lock \fBScopedLock\fP"
.br
.RI "\fIA simple 'resource acquisition is initialization' idiom type lock for \fBMutex\fP. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static std::string \fBgetThreadId\fP ()"
.br
.RI "\fIreturns the thread ID \fP"
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef boost::mutex \fBlog4cpp::threading::Mutex\fP"
.PP
.SS "typedef boost::mutex::scoped_lock \fBlog4cpp::threading::ScopedLock\fP"
.PP
.SS "typedef int \fBlog4cpp::threading::Mutex\fP"
.PP
Dummy type 'int' for \fBMutex\fP. 
.PP
Yes, this adds a bit of overhead in the for of extra memory, but unfortunately 'void' is illegal. 
.SS "typedef int \fBlog4cpp::threading::ScopedLock\fP"
.PP
Dummy type 'int' defintion of \fBScopedLock\fP;. 
.PP
.SS "typedef \fBMSMutex\fP \fBlog4cpp::threading::Mutex\fP"
.PP
A simple, non recursive \fBMutex\fP. 
.PP
.SS "typedef \fBMSScopedLock\fP \fBlog4cpp::threading::ScopedLock\fP"
.PP
A simple 'resource acquisition is initialization' idiom type lock for \fBMutex\fP. 
.PP
.SS "typedef omni_mutex \fBlog4cpp::threading::Mutex\fP"
.PP
A simple, non recursive \fBMutex\fP. 
.PP
Equivalent to Boost.Threads boost::mutex 
.SS "typedef omni_mutex_lock \fBlog4cpp::threading::ScopedLock\fP"
.PP
A simple 'resource acquisition is initialization' idiom type lock for \fBMutex\fP. 
.PP
Equivalent to Boost.Threads boost::scoped_lock. 
.SH "Function Documentation"
.PP 
.SS "std::string log4cpp::threading::getThreadId ()\fC [static]\fP"
.PP
returns the thread ID 
.PP
What these identifiers look like is completely up to the underlying thread library. 
.SH "Author"
.PP 
Generated automatically by Doxygen for log4cpp from the source code.
