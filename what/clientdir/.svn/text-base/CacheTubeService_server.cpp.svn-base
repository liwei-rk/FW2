// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <CacheTubeService.h>

#include <Thrift.h>
#include <TApplicationException.h>

#include <concurrency/ThreadManager.h>
#include <concurrency/PlatformThreadFactory.h>

#include <protocol/TBinaryProtocol.h>

#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <transport/TTransportUtils.h>

#include <server/TSimpleServer.h>
#include <server/TThreadPoolServer.h>
#include <server/TThreadedServer.h>
#include <server/TNonblockingServer.h>

#include <async/TEvhttpServer.h>
#include <async/TAsyncBufferProcessor.h>
#include <async/TAsyncProtocolProcessor.h>

#include <transport/TServerSocket.h>
#include <transport/TSSLServerSocket.h>
#include <transport/TSSLSocket.h>
#include <transport/THttpServer.h>
#include <transport/THttpTransport.h>
#include <transport/TTransportUtils.h>

#include <iostream>
#include <string>
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::concurrency;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::async;

using boost::shared_ptr;

namespace cachetube { namespace thrift
{
	class CacheTubeServiceHandler : virtual public CacheTubeServiceIf {
	public:
		CacheTubeServiceHandler() {
			// Your initialization goes here
		}

		void post(const std::string& queue_name, const std::vector<Message> & messages) {
			// Your implementation goes here
			//printf("post\n");
		}

		void get(std::vector<Message> & _return, const std::string& queue_name) {
			// Your implementation goes here
			//printf("get\n");
			for ( int32_t i = 0; i < 10; ++i ) {
				Message msg;
				msg.queue_name = queue_name;
				msg.message_id = static_cast< int64_t >( i );
				msg.source_ip = "172.22.0.31";
				(void)time( &msg.created_time );
				msg.content = " This is content ";
				_return.push_back( msg );
			}
			return;
		}

	};

	extern "C" int main(int argc, char **argv) {
		assert( 2 == argc );
		::std::string strMode = ::std::string( argv[1] );
		assert( true != strMode.empty() );
		int port = 9999;

		shared_ptr<CacheTubeServiceHandler> handler(new CacheTubeServiceHandler());
		shared_ptr<TProcessor> processor(new CacheTubeServiceProcessor(handler));

		shared_ptr<TServerSocket> serverSocket(new TServerSocket(port));

		shared_ptr<TTransportFactory> transportFactory(new TFramedTransportFactory());

		shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

		if ( "simple" == strMode  ) {
			TSimpleServer simpleServer(processor, serverSocket, transportFactory, protocolFactory);
			simpleServer.serve();
		} else if ( "thread-pool" == strMode ) {
			shared_ptr< ThreadManager > threadManager = ThreadManager::newSimpleThreadManager( static_cast<size_t>(4) );
			//shared_ptr< PlatformThreadFactory > threadFactory = shared_ptr< PlatformThreadFactory >( new PlatformThreadFactory() );
			shared_ptr<PlatformThreadFactory> threadFactory = shared_ptr< PlatformThreadFactory >( new PlatformThreadFactory() );

			threadManager->threadFactory( threadFactory  );
			threadManager->start(); 	

			TThreadPoolServer threadPoolServer( processor, serverSocket, transportFactory, protocolFactory, threadManager  );
			threadPoolServer.serve();
		} else if ( "threaded" == strMode ) {
			TThreadedServer threadedServer( processor, serverSocket, transportFactory, protocolFactory  );
			threadedServer.serve();
		} else if ( "nonblocking" == strMode ) {
			TNonblockingServer nonblockingServer( processor, port );
			nonblockingServer.serve();
		} else {
			::std::cout<<"simple "<<"thread-pool "<<"threaded "<<"nonblocking "<<::std::endl;
		}
		return 0;
	}
}
}

